# botva
is botva
# Server
## main()
В фуннкции main() сервера создается и биндится UDP соккет, который отвечает, за подключение клиента к серверу. Клиент отправялет свой никнейм и
получает в ответ два номера порта для отправки и получения сообщений, в то время как на сервере запускаются TCPRecvThread() и TCPSendThread() в
качестве потоков, в которые передаются те самые порты в качестве аргументов. Используется именно UDP сокет, потому что, не смотря на ненадежность
по сравнению с TCP, при использовании второго протокола, если после окончания обмена данными соккет клента по какой-либо причине не закроет
соединение, сервер будет ждать вечно, а если закроет соединение сервер придется ждать TCP_WAIT, которое по умолчанию равно 2 минутам.
Использование UDP позволяет этого исзбежать.
## map users
Публичный словарь users, ключами котрого яаляются никнеймы, а элементами структуры user, служит средством свзяи между TCPSendThread() и 
TCPRecvThread().
## struct user
В структуре user храниться std::condition_variable и std::mutex, которые в последушем используются для связи TCPSendTread() пользователя,
которому эта структура принадлжит и TCPRecvThread() пользователся, который хочет отправить сообшение. str_data, для передпчи данных в формате
std::string между двумя потоками. shut_down для передачи булевой информации - сигнала о завершении работы потока.
## TCPRecvThread()
Доя каждого пользователмя создаетмя поток с этой функцией. В этой функции сервер принимает данные от клиента. После подключения к клиенту и
отправки пользователем сообщения в первую очередь происходит общего закрытого ключа между пользователмя при помощи DH протокола.
DH протокол предусматривает следущий алгоритм передачи данных:

Отправитель (p_arr, public_keys)-> Аддресат

Отправитель <-(public_keys) Аддресат

Отправитель (сообщение)-> Аддресат

Сервер в этой цепи участвует лишь как передающее звено и не обрабатывает и не изменяет информацию. Алгоритм работы этой функции таков:
1)Сервер ожидает первый набор данных, состоящий из набора простых чисел и публичных ключей, от клиента;

2)Запись в поле str_data в sers, соответствующие аддресату и уведомление TCPSendThread() адресата при помощи std::condition_varible, которая была
получина при помощи users[(никнейм аддрсата)];

3)TCPRecvThread() ожидает уведомления от TCPSendThread();

4)Сервер отправляет отправителю публичные ключи аддресата, полученные от TCPSendThread(), (к этому моменту и получатель и аддресат получили общий
закрытый ключ шифрования AES);

5)Сервер ожидвет отправки отправителем зашифрованного сообщения;

6)Уведомление TCPSendThread() и передача сообщения так же, как и в шаге 2;

7)Ожидание квудомления от TCPSendThread() с информацией успешно ли дошло сообщение;

8)Отправка отправителю информации успешно ли дошло сообщение или же произошла ошибка;

На этои иоиенте цикл начинается заново
## TCPSendThread()
Эта функция так же создается в качестве потока для каждого пользователся, как и TCPRecvThread(). Служит для отправки сообщений клиенту.
Алгоритм работы:

1)Ожидание уведомления от TCPRecvThread();

2)Отправка аддресату данных из str_data(набор прочтых чисел, набор публичных ключей);

3)Получение данных от аддресата(набор открытых ключей);

4)Уведомление TCPRecvThread() и передача открытых ключей, как в TCPRecvThread()(шаг 2);

5)Ожидание уведомления от TCPRecvThread();

6)Отправка сообщения аддресату с зашифрованным сообщением;

7)Уведомление TCPRecvThread() и передача информации удачно ли дошло сообщение и если нет информации об ошибке;

Цикл начинается заново
# Client
## main()
Сперва в клиенте создается UDP соккет и отправялется на сервер никней пользователя, далее от сервера приходит два порта - для получения и отправки сообщений соответственно. Отправка сообщений происходит в основном потоке, а получение в потоке listenF().
## connectServ()
Используется для подключения к серверу по протоколу TCP, на вход подается номер порта, а возвращается уже подклченный соккет.
## sendMessage()
На вход подается TCP соккет, никнейм пользователя, кому необходимо отправить сообщение, и само сообщение. В начале устанавливается общий с получателем ключ шифрования AES по средствам протокола DH и после отправялется загифрованное сообщение: 

1)Генерируется набор простых чисел;

2)Генерируется набор открытых ключей;

3)Набор и ключи отправляются на сервер;

4)С сервера приходят открытые ключи аддресата;

5)С помошью полученных данных генерируется ключ шифрования AES;

6)Сообщение шифруется с помощью полученного ключа;

7)Сообщение отправялется на сервер;

8)С сервера приходит ответ, удачно ли дошло сообщение, или возникла ошибка;
## Прочие функции
### from_set() и to_set()
Используются для получения из информации типа std::string массива чисел, который будет в последущем использоваться для получени общего ключа
шифрования AES и перевода массива в std::string соответсвенно.
### from_ch() и to_ch()
Используются для получения вектора(std::vector) элементов std::string из цельной строки и перевода вектора в std::string соответсьвенно.
### toPCW()
Ранее использовалась для перевода информации типа std::string в PCW, что было необъодимо для правильного указания ip аддреса соккета. Сейчас не 
используется из-за ненадобности. Единственная функция, взятая из интернета, весь оставльной сревер написан полностью самомстоятельно и с нуля.
